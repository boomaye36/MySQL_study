# 15장

## 문자열

### 저장 공간

CHAR와 VARCHAR의 가장 큰 공통점은 문자열을 저장할 수 있는 데이터 타입이라는 점이고 가장 큰 차이는 고정 길이인지 가변 길이인지 여부이다. 

- CHAR 타입은 저장 공간의 크기가 고정적이다.
- VARCHAR 타입은 저장된 값의 유효 크기가 얼마인지를 별도로 저장해 둬야 하므로 1~2 바이트의 저장 공간이 추가적으로 더 필요하다.
- CHAR 와 VARCHAR의 선택 기준은 해당 칼럼이 얼마나 자주 변경되는지가 타입 선택의 기준이 되어야 한다.
    - CHAR 타입에서는 값이 고정돼있으므로 값을 변경하기 쉽지만 VARCHAR에서는 길이가 더 큰 값으로 변경될 떄에는 레코드 자체를 다른 공간으로 옮기거나 칼럼 값의 나머지 부분을 다른 공간에 저장 해야한다.

### 비교 방식

CHAR와 VARCHAR는 사용되지 않는 공간 뒤쪽에 공백 문자가 채워지면 이를 무시한다. 

그렇지만 앞쪽에 있는 공백문자는 유효한 문자로 취급한다. 

STRCMP()에서도 동일하게 적용

- LIKE 사용시 앞 뒤 공백 문자 모두 유효한 문자로 취급 → 공백문자를 무시하려면 %를 사용해야 한다.

### 클라이언트로부터 쿼리를 요청했을 때의 문자집합 변환

MySQL 서버는 클라이언트로부터 받은 메시지가 character_set_client에 지정된 문자집합으로 인코딩돼 있다고 판단하고 받은 문자열 데이터를 character_set_connection에 정의된 문자집합으로 변환한다. 

- SQL문장에서 별도로 문자집합을 설정하는 지정자를 인트로듀서라고 한다.
    - _와 문자집합의 이름을 붙여서 표현한다.

### 처리 결과를 클라이언트로 전송할 때의 문자집합 변환

character_set_connection에 정의된 문자집합으로 변환해 SQL을 실행한 다음 처리의 결과를 character_set_results 변수에 설정된 문자집합으로 변환해 클라이언트로 전송한다. 

- 문자집합, 콜레이션이 같다면 별도의 변환이 필요하지 않다.
- SET NAMES 명령은 현재 접속된 커넥션에서만 유효하지만 CHARSET 명령은 같은 프로그램에서 재접속할 때도 문자집합 설정이 유효하도록 만들어 준다.

---

## 콜레이션

문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙을 의미. 

- 비교나 정렬 순서에서 영문 대소문자를 같은 것으로 처리할지 아니면 더 크거나 작은 것으로 판단할지에 대한 규칙
- 문자열 칼럼의 값을 비교하거나 정렬하는 기준
- 문자집합은 2개 이상의 콜레이션을 가지고 있음. → 공유해서 사용 불가.

### 3개 파트로 구성된 콜레이션 이름

- 첫번째 파트 : 문자집합의 이름
- 두번째 파트 : 해당 문자집합의 하위 분류
- 세 번째 파트 : 대문자나 소문자의 구분 여부 - ci : 대소문자 구분하지 않음 cs : 대소문자 구분함

### 2개의 파트로 구성된 콜레이션 이름

- 첫번째 파트 : 문자집합의 이름
- 두번째 파트 : 항상 bin 이라는 키워드 사용

- 콜레이션과 관계없이 입력된 데이터의 대소문자는 별도의 변환없이 저장됨.
- 타입의 이름과 문자열의 길이, 문자집합과 콜레이션까지 일치해야 똑같은 타입 → 조인이나 WHERE 조건이 인덱스를 효율적으로 사용할 수 있다.

- WHERE 조건의 검색은 대소문자를 구분하지 않고 정렬은 대소문자를 구분 할 때 → 한 조건은 인덱스를 포기해야함 (주로 검색을 인덱스를 쓰게 함)
    - 정렬을 위한 콜레이션을 사용하는 칼럼을 하나 더 추가하고 검색은 원본 칼럼을, 정렬은 복사된 추출 칼럼을 이용하여 모두 인덱스 사용 가능

### 숫자

숫자를 지정하는 타입은 크게 값의 정확도에 따라 참값과 근사값 타입으로 나눌 수 있다. 

- 참값은 소수점 이하 값의 유무에 관계없이 정확히 그 값을 그대로 유지하는 것을 의미.  ex)  INTEGER, DECIMAL
- 근사값은 흔히 부동 소수점이라고 불리는 값을 의미하며, 처음 칼럼에 저장한 값과 조회된 값이 정확하게 일치하지 않고 최대한 비슷한 값을 관리하는 것을 의미. ex) FLOAT, DOUBLE

값이 저장되는 포맷에 따라 십진 표기법과 이진 표기법으로 나눌 수 있다. 

- 이진 표기법 : 프로그래밍 언어에서 사용하는 정수나 실수 타입. 한 바이트로 한 자리 또는 두 자리 숫자만 저장하는 것이 아니라 28까지의 숫자를 저장할 수 있다. → 숫자 값을 적은 메모리나 디스크 공간에 저장할 수 있다. ex ) INTEGER, BIGINT
- 십진 표기법 : 숫자 값의 각 자리 값을 표현하기 위해 4비트나 한 바이트를 사용해서 표기하는 방법. BIGINT로도 저장할 수 없는 값을 저장할 때 DECIMAL을 사용.

 

### 정수

- 양수만 저장하며 최대값이 UNSINGED의 2배인 UNSINGED 옵션을 명시하지 않으면 음수와 양수 모두 저장하는 SINGED 옵션이 된다.
- UNSIGNED 정수 카럼과 SIGNED 정수 칼럼을 조인 할 때 인덱스를 이용하지 못한다거나 하는 문제는 발생하지 않지만 저장되는 값의 범위가 다르므로 타입을 일치시키는 것이 좋다.

### 부동 소수점

소수점의 위치가 고정적이지 않으므로 숫자 값의 길이에 따라 유효 범위의 소수점 자리수가 바뀐다. 

- 유효 소수점 값을 식별하기 어렵고 그 값을 따져서 크다 작다 비교를 하기가 쉽지 않다.
- 근사값을 저장하는 방식이라서 동등 비교는 사용할 수 없다.
- 부동 소수점에 값을 저장해야 한다면 유효 소수점의 자리수만큼 10을 곱해서 정수를 만들어 그 값을 정수 타입의 칼럼에 저장하고 조회할 때는 10을 나눈 값으로 조회한다.

### DECIMAL

고정된 소수점까지만 정확하게 관리해야 할 때는 FLOAT나 DOUBLE 타입을 사용해선 안되고 DECIMAL 타입을 사용해야한다. 

- 정수를 사용하고자 한다면 DECIMAL 대신에 INTEGER나 BIGINT를 사용하는 것이 좋다.

### 정수 타입의 칼럼을 생성할 때의 주의사항

부동 소수점이나 DECIMAL 타입을 이용해 칼럼을 정의할 때는 타입의 이름 뒤에 괄호로 정밀도를 표시하는 것이 일반적이다. 

- 저장공간이 가변적이어서 저장공간을 명시해주는 DECIMAL과는 다르게 BIGINT 는 고정적인 저장공간을 가지고 있고 정수 뒤에 명시되는 괄호는 화면에 표시할 자리 수를 의미할 뿐 저장 가능한 값을 제한하는 용도가 아니다.
- ZEROFILL 옵션 : 실질 숫자 값의 앞쪽에 0을 패딩해서 가져올 것인지 설정하는 옵션 → UNSIGNED 타입 자동 캐스팅

### 자동 증가 (AUTO_INCREMENT) 옵션 사용

테이블의 프라이머리 키를 구성하는 칼럼의 크기가 너무 크거나 프라이머리 키로 사용할 만한 칼럼이 없을 때는 숫자 타입의 칼럼에 자동 증가 옵션을 사용해 인조 키를 생성할 수 있다. 

- AUTO_INCREMENT 옵션을 사용한 칼럼은 반드시 그 테이블에서 프라이머리 키나 유니크 키의 읿로 정의해야 한다.
- 프라이머리 / 유니크 키가 여러 개일 때
    - MyISAM : 자동증가 옵션이 사용된 칼럼이 프라이머리 키나 유니크 키의 아무 위치에나 올 수 있다.
    - InnoDB : 반드시 AUTO_INCREMENT 칼럼이 프라이머리 키 또는 유니크 키 중 적어도 하나의 인덱스에서는 제일 앞에 위치해야 한다.

- InnoDB : 프라이머리 키의 앞쪽에 위치한 칼럼의 값에 관계없이 항상 1씩 증가된 값이 저장된다.
- MyISAM : 앞쪽의 칼럼에 의존해 AUTO_INCREMENT 칼럼이 부터 시작할 수 있다.
- AUTO_INCREMENT 칼럼은 테이블당 하나만 사용할 수 있다.

---

## 날짜와 시간

- MySQL의 날짜 타입은 자체적으로 타임존을 관리하지 않으므로 DATETIME이나 DATE 타입은 현재 DBMS 커넥션의 타임존에 관계없이 클라이언트로터 입력된 값을 그대로 저장하고 조회할 때도 변환없이 그대로 출력한다.
- DATETIME에 저장된 날짜와 시간 정보는 커넥션의 타임존이 한국에서 미국의 로스엔젤레스로 변경돼도 전혀 차이가 없이 똑같이 조회된다.
- TIMESTAMP 칼럼은 타임존이 변경됨에 따라 그에 맞게 시간이 보정되어 조회된다.
- DATETIME의 값은 항상 MySQL 서버의 타임존으로 변환해서 저장한다.

### TIMESTAMP 타입의 옵션

TIMESTAMP 타입의 칼럼 값은 레코드가 UPDATE되거나 INSERT될 때 자동으로 현재 시간으로 변경된다.

- 아무런 옵션도 없이 2개 이상의 TIMESTAMP 칼럼이 있으면 첫번째만 타임스탬프 역할을 하고 나머지는 기능을 못한다.
- TIMESTAMP 옵션
    - TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP : 입력시 입력 값이 없으면 현재 시간으로 입력되고 변경되는 시점마다 변경 시간으로 자동 업데이트된다.
- TIMEATAMP DEFAULT CURRENT_TIMESTAMP
    - UPDATE 문장을 수행할 때마다 자동 업데이트는 되지 않고 초기 생성될 때 현재 시간으로 저장된다.
- TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP
    - 초기 기본값 설정은 비활성화되고 레코드가 변경될 때마다 시간 값이 저장된다.
- TIMESTAMP DEFAULT 0
    - 모든 옵션을 설정하지 않음 → 2개 이상 일 때 두번 째부터 자동적용 (명시 없으면)

---

## ENUM과 SET

### ENUM

ENUM 타입은 반드시 하나의 값만 저장할 수 있다. 

- ENUM 값의 역할은 코드화된 값을 관리하는 것이다. (java map 처럼 관리)
- 문자열 값이 길수록 저장 공간을 많이 절약할 수 있다.
- 기존의 ENUM값에 새로운 값을 추가할 때 테이블 구조를 변경해야 한다.
- 정렬을 위해선 CAST() 함수로 정수 값을 문자열 값으로 변환후 정렬해야 한다.  → 인덱스 정렬 불가능

### SET

SET 타입도 문자열 값을 정수 값으로 매핑해서 저장한다. 

- 하나의 칼럼에 하나의 값만 저장 가능하다.
- 값을 검색하기 위해서는 FIND_IN_SET() 또는 LIKE 검색을 할 수 있다.

## TEXT, BLOB

MySQL 에서 대량의 데이터를 저장하려면 TEXT나 BLOB 타입을 사용해야 하는데 두 타임의 유일한 차이점은 TEXT 타입은 문자열을 저장하는 대용량 칼럼이라서 문자집합이나 콜레이션을 가진다는 것이다. 

- TEXT, BLOB 사용하는 경우
    - 칼럼 하나에 저장되는 문자열이나 이진 값의 길이가 예측할 수 없이 클 때
    - 레코드의 크기가 64KB를 넘어서서 더 큰 칼럼을 추가할 수 없을 때
- Memory 스토리지 엔진은 가변 길이 타입 뿐만 아니라 TEXT나 BLOB과 같은 타입을 지원하지 않는다. → 메모리가 아닌 디스크에 저장 → SELECT 시 * 사용 지양
- 모든 내용을 가져올 필요가 없을 때 → CAST(), SUBSTRING() 이용해 임시 테이블이 메모리에 생성되도록 유도

---

## 공간 데이터 타입

라인이나 점 또는 다각형과 같은 정보를 저장할 수 있는 데이터 타입, 공간 데이터의 연산을 위한 확장 함수를 제공

### POINT 타입

X와 Y의 좌표로만 구성된 하나의 점 정보를 저장할 수 있는 데이터 타입. 

- POINT(x, y) : POINT() 함수는 숫자 값으로 된 두 개의 인자를 이용해 POINT 타입의 데이터를 생성
- GeomFromText(`POINT(x y)`) : 문자열로 표현된 좌표 값을 이용해 POINT 데이터를 생성. 하나의 문자열만을 인자로 사용.

### LINESTRING 타입

하나의 직선 뿐 아니라 여러 개의 꺾임이 있는 연결된 선도 모두 저장할 수 있다. 

- LINESTRING() : 라인의 시작 점과 중간의 꺾임이 발생하는 점을 연속해서 나열하고 마지막에는 종료 점을 명시한다. 각 점은 POINT() 함수를 이용해 표현
- LineStringFromText() : 점 좌표는 , 로 구분하되 각 점의 X 좌표와 Y 좌표는 공백으로 구분.

### POLYGON 타입

다각형을 저장할 수 있는 데이터 타입.