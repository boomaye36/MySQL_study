# 4장

### 트랜잭션

하나의 논리적인 작업 셋에 하나의 눠리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 모두 적용되거나 아무것도 적용되지 않아야 함을 보장해 주는 것

- 트랜잭션을 처리 할 때 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 트랜잭션 내에서 제거하는 것이 좋다.
- 처리 절차에서 묶어야 하는 작업을 한 트랜잭션으로 만든다.

## MySQL 엔진의 잠금

MySQL 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나뉜다. MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치게 되지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다. 

### 글로벌 락

SELECT 을 제외한 DDL, DML문장을 실행하는 경우 락이 해제될 때 까지 대기 상태로 남는다. MYSQL 서버 전체에서 영향을 미친다. 

### 테이블 락

개별 테이블 단위로 설정되는 잠금이다. 

### 유저 락

사용자가 지정한 문자열에 대해 반납, 해제 하는 잠금이다. 

### 네임 락

데이터베이스 객체의 이름을 변경하는 경우 획득하는 락

### 잠금 튜닝

잠금 대기 쿼리 비율이 높으면 테이블 잠금 때문에 경합이 많이 발생하고 있으면 처리 성능이 영향을 받고 있음을 의미하므로 테이블을 분리하거나 InnoDB 스토리지 엔진으로 변환하는 방법을 고려하는 것이 좋다.

### InnoDB 스토리지 엔진의 잠금

MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. 

- InnoDB는 레코드 자체를 잠그는 것이 아니라 인덱스의 레코드를 잠근다.
- Gap lock : 레코드와 레코드 사이의 간격에 새로운 레코드가 생성 되는 것을 제어하는 것.
- 넥스트 키 락 : 레코드 락과 갭 락을 합쳐놓은 형태의 잠금
- 자동 증가 락 : AUTO_INCREMENT시 테이블 수준의 락

### MySQL의 격리 수준

격리 수준이 올ㄹ라갈수록 각 트랜잭션 간의 데이터 고립 정도가 높아지며 동시에 동시성도 떨어진다. 

### READ UNCOMMITTED

각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보여진다. 

- 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데 다른 트랜잭션에서 볼 수 있게 되는 현상을 더티리드라한다.

### READ COMMITTED

- 더티 리드 같은 현상은 발생하지 않는다.
- 트랜잭션에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭션에서 그러한 변경 내역을 조회할 수 없다.
- NON-REAPEATABLE READ가 발생가능하다.

### REAPEATABLE READ

- MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다.
- 자신의 트랜잭션보다 작은 번호에서 변경한 것만 적용된다.
- 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상인 PHANTOM READ가 발생할 수 있다.

### SERIALIZABLE

가장 높은 격리 수준 - 동시성이 떨어짐