# 5장

## B-Tree

칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지

![Untitled](5%E1%84%8C%E1%85%A1%E1%86%BC%20f6af26f207e8425fbb462749eabcda03/Untitled.png)

- 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20 ~ 25% 를 넘어서면 인덱스를 이용하지 않는다.

## B-Tree 인덱슬르 통한 데이터 읽기

### 인덱스 레인지 스캔

- 검색해야할 인덱스의 범위가 주어졌을 때 사용.

### 인덱스 풀 스캔

- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는경우

### 루스 인덱스 스캔

- 중간마다 필요치 않은 인덱스 키값은 무시하고 다음으로 넘어간다.

인덱스가 다중 칼럼으로 구성되어 있다면 한 칼럼 없이는 다른 칼럼을 정렬할 수 없다.

## 해시 인덱스

- 동등 비교 검색에는 최적화돼 있지만 범위를 검색 한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다.
- 빠른 검색을 제공하지만 키 값 자체가 변환되어 저장되기 때문에 범위를 검색하거나 원본값 기준으로 정렬 할 수 없다.

## Fractal-Tree

- B-tree 인덱스에서 인덱스 키를 검색하거나 변경하는 과정 중에서 발생하는 디스크의 랜덤 I/O 가 상대적으로 많이 필요한 문제를 순차 I/O로 변환하여 처리한다.
- 인덱스보다 많은 정렬 작업이 필요하지만 인덱스의 단편화가 발생하지 않도록 구성할 수 있고, 인덱스 키 값을 클러스터링하기 때문에 B-Tree보다 대용량 테이블에서 높은 성능을 보장한다.

### 인덱스 알고리즘

- 구분자 기법 : 전문의 내용을 공백이나 텝 또는 마침표와 같은 문장 기호, 그리고 사용자가 정의한 문자열을 구분자로 등록한다.
- N-그렘 기법 : 본문을 무조건적으로 몇 글자씩 잘라서 인덱싱하는 방법.

### 전문 인덱싱

전문 인덱스를 사용하려면 반드시 Match Against 구문으로 검색 쿼리를 작성해야한다. 

### 클러스터링 인데스

클러스터란 여러 개를 하나로 묶는 다는 의미

인덱스에서 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현

- 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장한느 것을 클러스터링 인덱스라고 표현한다.
- 프라이머리 키값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야한다.
- InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느릴 수 밖에 없다.
- 프라이머리 키가 명시돼있지 않으면 유니크 인덱스나 자동생성된 값을 채택
- 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키값을 저장한다.

### 유니크 인덱스

유니크란 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음 을 의미하는데 인덱스 라기보다는 제약 조건에 가깝다. 

### 외래키

- 자식 테이블의 외래키 칼럼의 변경은 부모 테이블의 확인이 필요한데 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있으면 해당 쓰기 잠금이 해제될 때 까지 기다린다.
- 자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다.
- 물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 해당 참조기카 부모 테이블에 있는지 확인해야한다.