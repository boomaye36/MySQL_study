# 14장

# 데이터 모델링

- 논리 모델링 : 업무를 분석하고 그에 대한 데이터 집합과 그 집합 간의 관계를 중점적으로 표현
- 물리 모델링 : 논리 모델링의 산출물을 시스템으로 어떻게 표현할지를 고려

## 논리 모델링

### 엔터티

클래스와 동급의 의미. 

- 엔터티와 테이블은 항상 1 : 1 의 관계로 구현되는 것은 아니다. 2개 이상의 엔터티가 물리 모델링 단계에서 통합되기도 하고 하나의 엔터티가 여러 개의 물리적 테이블로 구현되기도 한다.

### 식별자

프라이머리 키 또는 식별자는 하나의 엔터티에서 개별 레코드를 식별할 수 있는 어트리뷰트의 조합을 의미한다. 

- 본질 식별자 : 그 엔터티의 레코드가 생성되는 조건을 알려주는 식별자
- 인조 식별자 : 인위적으로 생성한 어트리뷰트인 식별자

### 관계 (릴레이션)

ERD는 엔터티와 릴레이션의 다이어그램. 

### 식별 관계와 비식별 관계

- 식별 관계 : 부모의 식별자가 자식 엔터티의 레코드를 식별하는 데 꼭 필요한 것
- 비식별 관계 : 부모 엔터티의 식별자 없어도 자식 엔터티의 레코드가 생성될 수 있는 것

→ 부모 엔터티가 자식 엔터티를 만들어 내는 데 필수적인 역할을 하고있는지 확인

- 자식 엔터티의 레코드가 생성되는 데 꼭 부모 엔터티가 필요하더라도 모두 식별 관계를 적용해야 하는 것은 아니다.
    - 어떤 작업의 주체에 해당하는 엔터티는 거의 모든 엔티에 결정적인 영향을 미치게 된다. 이를 모두 식별관계로 나타내는 것은 효율적이지 못하다.
    - 각 관계 중에서 유일성을 보장할 수 있는 최소한의 대표 관계만 식별 관계로 선택하고 나머지 관계는 비식별 관계가 된다.
- 식별 관계라고 해서 무조건 부모의 실질 식별자만 자식 엔터티로 넘어갈 수 있는 것은 아니다.

### 관계의 기수성

부모 엔터티의 레코드 하나에 대해 자식 엔터티의 레코드가 얼마나 만들어질 수 있는지를 의미.

ex ) 한 명의 회원은 한 번도 구매를 하지 않을 수도 있지만 한번 이상 구매할 수도 있음.

---

### 계층 관계

부모와 자식 간의 직선적인 관계가 연속되는 형태

- 자식 엔터티로 갈수록 식별자를 구성하는 어트리뷰트의 개수가 많아지므로 적절한 수준에서 자식 엔터티의 식별자를 인조 키로 대체하는 것이 좋다.

### 순환관계

하나의 엔터티가 부모임과 동시에 자식 엔터티가 되는 재귀적인 형태

- 절대 식별 관계가 될 수 없다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled.png)

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled%201.png)

### M : M 관계

- M : M 관계 해소 : 물리 모델로 넘어오면서 두개의 1 : M 관계로 풀어주는 것

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled%202.png)

- M : M 에서의 관계 선이 엔터티로 변환

### BOM 관계

부품을 결합해서 또 다른 부분을 만들고 만들어진 새로운 부품은 또 다시 다른 부품의 조립 시에 사용되는 형태. 

물리적인 모델링 단계로 넘어오면 M : M 관계가 해소되어야 한다.

### 베타 관계

어떤 엔터티가 서로 다른 두 부모 엔터티로부터 관계를 가지고 있는데 각 관계가 서로 배타적으로만 존재하는 것.

- 배타적 관계가 있다면 각 부모 엔터티를 하나의 엔터티로 통합 할 수 있는지를 검토해 보는 것이 좋다.

### 엔터티의 통합

엔터티의 통합은 전체 모델링 작업 전 과정에서 항상 염두에 두고 진행하는 것이 좋다. 

- 엔터티를 구성한는 어트리뷰트와 관계가 비슷한 엔터티는 통합의 대상이 아닌지 확인.

### 관계의 통합

관계를 통합하면 조인하거나 저장하는 테이블이 하나 더 늘어나기 때문에 개발하기가 더 번거로울 수 있다. 따라서 관계의 통합은 성능적인 이슈보다는 업무 요건의 변화에 유연하게 대응하기 위한 것이다. 

---

## 모델 정규화

모델에서 중복된 데이터를 최소화하고 일반적으로 납득될 수 있는 모델로 만드는 것. → 각 어트리뷰트가 적절한 엔터티에 배치되고 각 어트리뷰트가 중복된 데이터를 갖지 않음

- 논리 모델에서 진행하는 정규화 : 데이터의 저장 비용을 최소화 (중복 제거)
- 물리 모델링에서 진행하는 반정규화 : 데이터를 읽어 오는 비용을 최소화

### 제 1정규화

모든 속성은 반드시 하나의 값을 가져야 한다. 

- 한 개 이상의 속성을 가지는 어트리뷰트를 별도의 자식 엔터티도 분리한다.
- 서버는 유지보수와 기능 추가가 발생하므로 가능하면 반복되는 정보는 자식 엔터티로 분리해서 독립 시켜야한다. → 별도의 자식 엔터티로 분리 한 다음 primary key로 구분

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled%203.png)

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled%204.png)

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled%205.png)

### 제 2 정규화

식별자 일부에 종속되는 어트리뷰트는 제거해야 한다. 

- 조회 성능의 향상을 위해 일부 어트리뷰트를 복사해 두는 반정규화를 사용하는데 정규화 이전에 사용하는 것은 좋은 방법이 아니다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled%206.png)

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled%207.png)

### 제 3정규화

식별자 이외의 속상 간에 종속 관계가 존재하면 안 된다. 

- 식별자가 아닌 모든 어트리뷰트는 식별자에 종속성을 가져야 함과 동시에 식별자가 아닌 모든 어트리뷰트 간에는 종속 관계 없이 독립적이어야 한다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled%208.png)

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20f1684edde1674079aaf3998bd7950de9/Untitled%209.png)

---

## 물리 모델링

물리 모델링에서는 논리 모델을 통해 나온 산출물을 RDBMS의 특성에 맞게 변환하는 작업을 수행한다. 

- 논리 모델에서 신경 쓰지 않았던 M : M 관계와 같이 RDBMS에 구현할 수 없는 구조를 해소하는 작업
- 프라이머리 키의 칼럼 순서 선정
- 칼럼의 이름 부여
- 칼럼의 데이터 타입 선정
- 조회 성능을 위한 반정규화

### 프라이머리 키 선택

논리 모델링에서 식별자는 최대한 간결하면서도 엔터티의 레코드를 대표할 수 있는 어트리뷰트의 집합으로 선정했다. 

- 너무 많은 칼럼이 프라이머리 키로 참여하지 않게 Auto-Increment 같은 인조 키나 시퀸스를 부여하는 방법이 사용된다.
- 프라이머리 키도 하나의 인덱스로써 사용되므로 반드시 SELECT의 조건 절에 자주 사용되는 칼럼 위주로 순서를 배치해야 한다.

### 데이터 타입 선정

물리 모델링에서 칼럼의 데이터 타입은 가능한 한 최소 단위의 타입을 부여해야 한다. 

### 데이터의 타입

- 각 데이터 타입별로 차지하는 공간이나 성격을 잘 모른다면 저장하려는 데이터 성격별로 그대로 타입을 선정하는 것이 좋다.
- 편의성과 성능, 레코드 건수 등을 따져서 적절한 방법을 선택해야 한다.

### 문자집합(캐릭터 셋)

- MySQL에서는 정렬이나 그룹핑과 같은 임시 테이블 또는 버퍼 작업을 위해 별도의 메모리 할당이 필요하다.
- MySQL 서버는 실제 칼럼에 저장된 데이터의 길이로 메모리를 할당하고 사용하는 것이 아니라 데이터 타입에 명시된 길이를 기준으로 메모리 공간을 할당하고 사용한다. → 메모리 공간을 초과하면 메모리가 아니라 디스크에서 처리하게 된다.

### NOT NULL & NULL

- MyISAM 스토리지 엔진 : NULL을 저장하든 NULL을 대체해서 빈 문자열을 저장하든 사용하는 디스크 공간의 크기는 없다.
- InnoDB 스토리지 엔진 : 칼럼이 NULL이면 길이가 고정된 타입이나 가변 타입 모두 NULL이 저장되는 칼럼은 전혀 디스크 공간을 사용하지 않는다.
- NULL을 인덱스에 포함하므로 NULL로 검색되는 조건은 인덱스 레인지 스캔이 가능하다.
- 디스크 공간 절약의 문제가 아니라 옵티마이저가 얼마나 쿼리를 더 최적화할 수 있게 환경을 만들어줄 것 인가의 관점

### 도메인

일관되지 않은 데이터 타입의 사용을 막기 위해 전사적으로 사용하는 데이터의 성격을 적절한 수준으로 분류해 도메인이라는 개념으로 그룹핑하고 DBMS의 데이터 타입을 부여한다. 

---

## 반정규화

모델을 정규화 할 수록 데이터 변경 작업에 최적화된 모델을 만들지만 SELECT 쿼리에서 필요한 테이블의 수 뿐만 GROUP BY 나 쿼리 자체의 개수도 증가한다. → GROUP BY 하는 쿼리는 실시간으로 처리하기 부담스러울 수있다.

- GROUP BY 나 COUNT(*) 같이 많은 레코드를 대상으로 하는 작업을 빠르게 조회하기 위해 미리 건수를 집계해서 별도의 테이블이나 칼럼으로 저장해두는 것

### 칼럼 복사

복사한 칼럼을 이용해 GROUP BY 나 ORDER BY 처리를 인덱스로 할 수 있다면 성능상 도움이 될 수 있다. 

- 정렬을 위한 용도 : ORDER BY 처리는 인덱스를 이용하지 못하고 filesort 과정을 거쳐야 하는데 특정 칼럼을 복사해 두고 인덱스를 생성한다면 인덱스를 이용해 처리할 수 있다.

### 요약 칼럼

어떠한 계산의 결과로 만들어진 값을 저장하기 위해 반정규화한 칼럼

- 게시판의 목록을 조회할 때 게시물 수를 함께 출력해야 할 때
- 특정 게시판의 상세 내용을 출력할 때 게시물 수를 함께 출력해야할 때
    - 방법
    - 원본 데디터가 변경될 때마다 실시간으로 요약 칼럼의 값을 증가 - 대기 시간 증가
    - 백 그라운드 프로세스로 요약 칼럼의 값을 증가
    - 2-30분 단위로 모아서 배치 형태로 요약 칼럼의 값을 증가 - 효율적

### 해시 인덱스

해시 인덱스는 동등 비교를 가장 빠르게 처리할 수 있는 인덱싱 방법이다. - 해시 값으로 인덱스 구성 

MyISAM 이나 InnoDB 스토리지 엔진은 해시 인덱스를 지원하지 않는다.