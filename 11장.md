# 11장

## 스토어드 프로그램의 장단점

스토어드 프로그램은 절차적인 처리를 제공하긴 하지만 애플리케이션을 대체할 수 있을지 고려해봐야한다. 

### 장점

- 데이터베이스의 보안 향상 : 자체적인 보안 설정 기능을 가지고 있으며 스토어드 프로그램 단위로 실행 권한을 부여할 수 있다.
- 기능의 추상화 : 일련번호 생성용 프로그램을 MySQL 서버의 스토어드 프로그램으로 구현한다면 애플리케이션 뿐 아니라 SQL 클라이언트에서도 쉽게 이용할 수 있다.
- 네트워크 소요 시간 절감 : 각 쿼리가 큰 데이터를 클라이언트로 가져와서 가공한 후 다시 서버로 전송해야 한다면 더 큰 네트워크 경유 시간이 소모될 것이다.
- 절차적 기능 구현 : DBMS 서버에서 절차적인 기능을 실행할 수 있는 제어 기능을 제공한다. → 네트워크 경유에 걸리는 시간을 줄일 수 있고 불필요한 애플리케이션 코드를 줄일 수 있다.
- 개발 업무의 구분

### 단점

- 낮은 처리 성능 : 문자열 숫자 연산에 스토어드 프로그램을 이용하는 것은 좋지 못하다.
- 애플리케이션 코드의 조각화 : 코드가 자바나 MySQL 스토어드 프로그램으로 분산된다면 설치나 배포가 더 복잡해지고 유지보수 또한 어려워진다.

### 스토어드 프로지서

스토어드 프로시저는 서로 데이터를 주고받아야 하는 여러 쿼리를 하나의 그룹으로 묶어서 독립적으로 실행하기 위해 사용하는 것

ex) 배치 프로그램에서 첫 번째 쿼리의 결과를 이용해 두 번째 쿼리를 실행해야 할 때

- 스토어드 프로시저는 반드시 독립적으로 호출돼야 하며 SELECT 나 UPDATE와 같은 SQL 문장에서 스토어드 프로시저를 참조할 수 없다.

- 스토어드 프로시저는 기본 반환값이 없다. → RETURN 명령어 사용 못함
- 스토어드 프로시저의 각 파라미터는
    - IN 타입으로 정의된 파라미터는 입력 전용 파라미터를 의미.
    - OUT 타입으로 정의된 파라미터는 출력 전용 파라미터
    - INOUT 타입으로 정의된 파라미터는 입력 및 출력 용도로 모두 사용할 수 있다.
    - DELIMITER : 명령의 끝을 알려주는 종료문자

- 스토어드 프로시저는 출력 처리를 하지 않아도 쿼리의 결과가 클라이언트로 전송된다 → 이를 이용해 디버깅도 가능하다.

### 스토어드 함수

스토어드 함수는 하나의 SQL 문장으로 작성이 불가능한 기능을 하나의 SQL 문장으로 구현해야 할 때 사용한다. 

- CREATE FUNCTION 명령으로 생성 가능.

### 실행

CALL 명령으로 실행할 수 없다. SELECT 문장을 이용해 실행한다. 

## 

---

## 트리거

트리거는 테이블의 레코드가 저장되거나 변경될 때 미리 정의해둔 작업을 자동으로 실행해주는 스토어드 프로그램이다.  

칼럼의 유효성 체크나 다른 테이블로의 복사나 백업을 위해 트리거를 사용한다. 

### 트리거 생성

트리거는 CREATE TRIGGER 명령으로 생성한다. 스토어드 프로시저나 함수와는 달리 BEFORE나 AFTER 키워드로 트리거가 실행될 이벤트를 명시할 수 있다. 

---

## 이벤트

주어진 특정한 시간에 스토어드 프로그램을 실행할 수 있는 스케줄러 기능

### 이벤트 생성

- 반복성 이벤트 : 매일 같은 시간에 반복해서 실행

```sql
CREATE EVENT daily_ranking
ON SCHEDULE EVERY 1 DAY STARTS '2023-01-01 01:00:00' ENDS '2023-12-12 01:00:00'
DO
INSERT INTO daily_rank_log VALUES(NOW(), 'Done');
```

- 일회성 이벤트 : 단 한번만 실행되는 이벤트. EVERY 절 대신 AT

- 이벤트의 처리 내용을 작성하는 DO 절은 단순히 하나의 쿼리나 스토어드 프로시저를 호출하는 명령을 사용하거나 BEGIN .. END로 구성되는 복합 절을 사용할 수 있다.

---

## 스토어드 프로그램 본문 작성

### BEGIN…END 블록과 트랜잭션

스토어드 프로그램의 본문은 BEGIN으로 시작해서 END로 끝나며 하나의 블록에는 여러 블록을 중첩해서 포함할 수 있다.

- 스토어드 프로시저나 이벤트에서만 트랜잭션을 사용 가능하고 스토어드 함수나 트리거에서는 사용 불가.
- 스토어드 프로시저 내부에서 트랜잭션을 완료하면 이 스토어드 프로시저를 호출한 애플리케이션이나 SQL 클라이언트 도구에서는 트랜잭션을 조절할 수 없다.
- 트랜잭션 내부에서 COMMIT이나 ROLLBACK 명령으로 트랜잭션을 완료하면 스토어드 프로시저 외부에서 COMMIT이나 ROLLBACK을 실행해도 아무 의미가 없다.

### 트랜잭션 외부에서 트랜잭션 완료

스토어드 프로시저 내부에서 트랜잭션을 완료할지 또는 프로시저를 호출하는 클라이언트에서 확인 과정을 거친 후에 커밋이나 롤백할지를 결정해야한다. 

### 변수

- 사용자 변수 : 현재 커넥션에서는 스토어드 프로그램 내부나 외부 어디서든 사용 가능
- 로컬변수 : 처리가 빠르게됨, 스토어드 프로그램의 BEGIN … END 사이에서만 사용 가능

---

## 핸들러와 컨디션을 이용한 에러 핸들링

- ERROR-NO : 4자리 숫자 값으로 구성된 에러 코드 , MySQL 에서만 유효한 에러 식별 번호
- SQL-STATE : 다섯 글자의 알파벳과 숫자로 구성되며 에러 뿐 아니라 여러 가지 상태를 의미하는 코드

- 에러 메시지는 똑같은데 에러 번호가 다를 수 있다. 똑같은 원인의 에러라 하더라도 MySQL 서버의 스토리지 엔진별로 SQL문장의 종류별로 다른 에러 번호를 가질 수 있다.

### 핸들러

```sql
DECLARE handler_type HANDLER
	FOR condition_value[, condition_value]...
	handler_statements
```

### 컨디션

어떤 조건이 발생했을 때 실행할지를 명시하는 방법

### 시그널

사용자가 직접 예외를 발생시키는 기능

핸들러 → catch, 시그널 → throw

- DECLARE 구문 대신 SIGNAL 구문을 사용하여 스토어드 프로그램을 나타낼 수 있다.
    - 직접 SQLSTATE 값을 가질 수 있고
    - 간접적으로 SQLSTATE 를 가지는 컨디션을 참조해서 에러나 경고를 발생시킬 수 있다. → 항상 SIGNAL 명령은 SQLSTATE와 연결돼야한다.
- SIGNAL 명령으로 에러를 발생시킬지 경고를 발생시킬지는 SQLSTATE 값으로 결정된다
    - 00 - 정상 처리됨
    - 01 - 처리 중 경고 발생
    - others - 처리 중 오류 발생

### 커서

- 스토어드 프로그램의 커서는 전방향 읽기만 가능하다
- 스토어드 프로그램에서는 커서의 칼럼을 바로 업데이트 하는 것이 불가능하다.

1. 인센서티브 커서 : 일치하는 레코드를 별도의 임시 테이블로 복사해서 가지고 있는 형태
2. 센서티브 커서 : 일치하는 레코드에 대한 정보를 실제 레코드의 포인터만으로 유지하는 형태

### DEFINER와 SQL SECURITY 옵션

- DEFINER는 스토어드 프로그램이 기본적으로 가지는 옵션으로 해당 스토어드 프로그램의 소유권과 같은 의미를 가진다.
- SQL SECURITY 옵션은 스토어드 프로그램을 실행할 때 누구의 권한으로 실행할지 결정하는 옵션이다.

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC%201f212ff2d5164ecd93767b000cb18764/Untitled.png)

- 사용자에게 mysql DB에 있는 테이블 가운데 일부를 제한된 수준으로 조회하거나 변경하는 작업을 허용해야 할 때 → 꼭 필요한 작업만 스토어드 프로그램으로 개발하고 DEFINER 와 SQL SECURITY 옵션을 적절히 조절

###