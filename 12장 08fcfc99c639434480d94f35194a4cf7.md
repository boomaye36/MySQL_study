# 12장

## InnoDB의 기본 잠금 방식

### SELECT

REPEATABLE-READ 보다 더 높은 격리 수준인 SERIALIZABLE 격리 수준에서는 모든 SELECT 쿼리는 읽기 잠금을 걸고 레코드를 읽는다. → 서버의 처리 성능이 떨어지게됨. 

- LOCK IN SHARE MODE : 읽기 잠금만 걸기 때문에 잠금을 획득한 트랜잭션에서도 변경하려면 쓰기 잠금을 다시 획득해야 한다.
- FOR UPDATE : 변경해야 할 때 사용. 다른 트랜잭션에 영향이 큼 (처음부터 쓰기잠금 사용)

→ COMMIT, ROLLBACK 이 실행되면 잠금이 해제 ⇒ 한 트랜잭션에서만 유효

## INSERT, UPDATE, DELETE

- 기본적으로 쓰기 잠금 사용, 읽기 잠금도 사용 가능
- AutoCommit 상태에서도 잠금을 걸고 해제하는 작업은 생략하지 않음
- AutoCommit 상태에서도 BEGIN, START로 명시적으로 트랜잭션을 시작하면 수동으로 종료해야함

- InnoDB에서 UPDATE, DELETE 문장을 실행할 때 SQL 문장이 조건에 일치하는 레코드를 찾기 위해 참조하는 인덱스의 모든 레코드에 잠금을 건다. → 조건에 일치하지 않는 레코드도 잠금의 대상이 될 수 있다.
- 작은 테이블이라도 UPDATE나 DELETE를 사용할 경우 인덱스를 생성하는 것이 좋다.
- InnoDB에서는 UPDATE가 실행될 때 인덱스를 기반으로 레코드를 잠근다. ⇒ 인덱스가 없으면 사원 테이블의 모든 레코드에 잠금을 걸고 조건에 일치하는 레코드의 칼럼 값을 변경한다.

### SELECT 쿼리의 잠금

기본 형태의 SELECT, INSERT 쿼리는 언두로그를 이용해 레코드를 읽는다. 따라서 트랜잭션의 쿼리에 영향을 받지 않고 레코드를 대기하지도 않는다.

그렇지만 SERIALIAZABLE에서는 읽기잠금을 획득한 후 읽기를 실행한다. 

### SELECT FROM LOCK IN SHARE MODE

WHERE 절에 일치하는 레코드 뿐 아니라 검색을 위해 접근한 모든 레코드에 대해 공유 넥스트 키 락을 필요로 한다. 이 잠금은 트랜잭션이 종료되면 해제된다.

### SELECT FROM FOR UPDATE

FOR UPDATE가 사용되면 SELECT 쿼리는 스냅 샷을 이용한 읽기를 사용하지 못하기 때문에 일관된 읽기가 무시된다. 

## INSERT 쿼리의 잠금

- 배타적 잠금 사용
- 프라이머리 키나 유니크 키가 존재한다면 중복 체크를 위해 공유 레코드 락을 먼저 획득해야 한다.
- 인서트 인텐션 락 : INSERT를 실행할 의도를 지닌 쿼리가 획득해야 하는 잠금
- 갭락의 일종으로 여러 트랜잭션이 동시에 인서트 인텐션 락을 획득 가능
- 사용 이유 : InnoDB의 갭 락으로 인한 동시성 감소를 최소화

```sql
-- 트랜잭션 1
BEGIN;
INSERT INTO tb_test VALUES(5);

-- 트랜잭션 2
BEGIN;
INSERT INTO tb_test VALUES(4);

-- 트랜잭션 3
BEGIN;
INSERT INTO tb_test VALUES(3);
```

### 인서트 인텐션 락이 없으면

새로운 프라이머리 값을 INSERT하기 위해 간격을 잠가야 하며 이때 배타적 갭 락을 사용할 것이다. 

→ 순차적으로 실행되어야함. 

### 인서트 인텐션 락을 사용하면

3개의 트랜잭션이 모두 1부터 6까지의 간격에 대한 인서트 인텐션 락을 동시에 획득한다. 

서로 충돌하는 값을 INSERT 하지 않는 이상 동일 간격에 대해 서로 간섭을 받지 않고 동시에 INSERT가 처리될 수 있다. 

- 중복된 키가 존재할 경우 InnoDB는 반드시 기존의 중복된 레코드에 공유 레코드 락을 걸어야 한다.

→ 중복 키 오류를 발생시킨 트랜잭션이 COMMIT이나 ROLLBACK 명령으로 종료될 때까지는 중복된 값을 가진 레코드가 다른 트랜잭션에 의해 변경되거나 삭제되면 안 되기 때문.  

- 공유 잠금 : 그 레코드나 간격을 읽을 때 다른 트랜잭션이 변경하지 못하게 하는 용도 → 내가 읽는 동안 남들이 내가 읽고 있는 데이터를 변경하거나 삭제하지 못하게 막는 장치
- 베타적 잠금 : 해당 트랜잭션에서 그 레코드나 간격을 변경하기 위해 획득해야 하는 잠금 → 내가 쓰기를 하는 동안 남들이 쓰지 못하게 하는 것

각 트랜잭션별로 순차적으로 INSERT 쿼리가 실행된 후 COMMIT이나 ROLLBACK 명령이 수행되지 않으면

- 1번 트랜잭션에서는 1인 레코드에 대해 배타적 레코드 잠금을 갖는다.
- 트랜잭션 2번과 3번은 1번에서 점유한 레코드 잠금 떄문에 공유 잠금을 획득하기 위해 대기하게 된다.

```sql
-- 트랜잭션 1
ROLLBACK;
```

이후 롤백 명령을 수행하면 트랜잭션 1번이 가지고 있던 배타적 레코드 잠금이 해제된다

동시에 트랜잭션 2번과 3번은 프라이머리 키값이 1인 레코드에 대해 공유 레코드 잠금을 걸게 된다. 

→ 일정 시간이 초과되면 에러가 발생 후 종료

⇒ 2번과 3번 트랜잭션에서 INSERT를 수행한 후 50초 이내에 1번 트랜잭션에서 ROLLBACK을 수행하여야함.   

- INSERT INTO … ON DUPLICATE KEY UPDATE : INSERT 하려는 레코드에 대해 중복된 키 값이 이미 있는지 판단하기 위해 공유 잠금을 걸어야 한다. 레코드가 존재한다면 베타적 잠금을 걸고 업데이트를 수행하고 없다면 인텐션 락을 걸고 INSERT를 수행한다. 새로이 INSERT된 레코드에 대해서는 베타적 잠금을 획득한다.
- REPLACE : 중복 키값 확인 → 공유 잠금, 나머지도 위와 같음

### INSERT INTO tb_new … SELECT … FROM tb_old

- tb_new → INSERT하기 위해 베타적 레코드 락
- tb_old → 읽어오기 위해 공유 넥스트 락

<공유 잠금을 해결하기 위한 방법>

- MySQL의 트랜잭션 격리 수준을 READ-COMMITTED로 변경하고 innodb_locks-unsafe-binlog를 활성화한다. → 오차를 묵인하는 방법
- MySQL의 복제 방식을 SBR이 아닌 RBR로 변경하는 것 → 비합리적
- INSERT INTO … SELECT… 쿼리를 두 개의 쿼리로 나눠서 실행 → 별도의 디스크 I/O를 만들어 내지만 효과적인 방법

### REPLACE INTO tb_new … SELECT … FROM tb_old

INSERT와 마찬가지 

## UPDATE 쿼리의 잠금

단순 UPDATE 문장은 WHERE 조건에 일치하는 레코드를 찾기 위해 참조한 모든 레코드에 베타적 넥스트 키락을 걸게 된다. → 간격까지 잠그는 것은 팬텀 레코드의 발생을 막기 위한 것이다. 

### UPDATE tb_test1 a, tb_test2 b ON … SET a.column = b.column

JOIN UPDATE 문장에서는 최종적으로 UPDATE 되는 칼럼이 포함된 모든 테이블의 레코드에는 배타적 넥스트 키 락이 걸리고 그 밖의 단순 참조용으로만 사용되는 테이블에는 공유 넥스트 키 락이 설정된다. 

- 넥스트 키 락 사용이유 : 팬텀 레코드의 방지

DELETE도 마찬가지

### InnoDB에서 여러 쿼리 패턴 간의 잠금 대기

- InnoDB의 동시성을 최대로 만들려면 레코드 기반의 복제를 사용하고 격리 수준은 READ-COMMITTED로 조정하는 것이 가장 좋다.

### InnoDB에서 데드락 만들기

InnoDB에서 대부분의 데드락은 공유 잠금을 가진 상태에서 다시 배타적 잠금을 얻으려고 하는 잠금 업그레이드 상황에서 자주 발생한다.