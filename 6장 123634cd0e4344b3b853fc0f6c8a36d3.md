# 6장

### 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다. 
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다. 

### 옵티마이저의 종류

- 규칙 기반 최적화 : 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위 에 따라 실행 계획을 수립하는 방식
- 비용 기반 최적화 : 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출한다.

### 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보다. 

### 실행 계획 분석

EXPLAIN 명령은 EXPLAIN 키워드 뒤에 확인하고 싶은 SELECT 쿼리 문장을 적으면 된다. 

- UPDATE, INSERT, DELETE 문장에 대해서는 실행 계획을 확인할 방법이 없다.

### select_type 칼럼

- simple : UNION 이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우
- primary : UNION 이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리
- UNION : UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type
- DEPENDENT UNION : 내부 쿼리가 외부의 값을 참조해서 처리될 때 → 외부 쿼리에 의존적이므로 비효율적인 경우가 많다.
- UNION RESULT : UNION 결과를 담아두는 테이블
- SUBQUERY : FROM 절 이외에서 사용되는 서브쿼리
- DEPENDENT SUBQUERY : 서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우
- DERIVED : 서브 쿼리가 FROM 절에 사용된 경우, 파생 테이블에는 인덱스가 없으므로 다른 테이블과 조인할 때 성능상 불리하다. → 가능하다면 조인으로 바꿔주는 것이 좋다.
- UNCACHEABLE SUBQUERY
    - subquery는 바깥쪽의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.
    - DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 칼럼의 값 단위로 캐시하고 사용한다.
- UNCACHEABLE UNION : UNION과 UNCACHEABLE 혼합

### table 칼럼

MySQL 의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 

- Table 칼럼에 <>로 둘러싸인 이름이 명시 되는 경우가 있는데 이 테이블은 임시 테이블을 의미한다.
- MySQL은 Derived는 반드시 별칭을 가져야 한다.

## type 칼럼

type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미한다. 이는 인덱스를 사용해 레코드를 읽었는지 처음부터 끝까지 읽는 풀 테이블 스캔으로 읽었는지를 의미한다. 

## system

레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법을 system이라고한다. 

## const

테이블의 레코드의 건수에 관계없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며 반드시 1건을 반환하는 쿼리의 처리 방식이다. 

프라이머리 키의 일부만 조건으로 사용할 때는 ref으로 표시된다. 

### eq_ref

여러 테이블이 조인되는 쿼리의 실행 계획에서 표시.

조인에서 처음 읽은 테이블의 칼럼 값을, 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 서용 할 때. 

조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 한다.

### ref

 조인의 순서와 상관없이 사용, 프라이머리 키나 유니크 키 등의 제약 조건도 없다. 

인덱스의 종류와 관계없이 동등 조건으로 검색할 때 사용 (검색 속도 빠른편)

### full text

MySQL 전문검색 인덱스를 사용해 레코드를 읽는 접근 방법. 

- 전문 검색은 MATCH … AGAINST … 구문을 사용하는데 반드시 해당 테이블에 전문 검색용 인덱스가 준비돼 있어야한다.
- 전문 인덱스보다 일반 인덱스를 이용하는 range 방식이 접근이 빠른 편

### unique_subquery

WHERE 조건절에서 사용할 수 있는 IN 형태의 접근 방식이다. 

서브쿼리에서 중복되지 않은 유니크한 값만 반환한다. 

### index_subquery

IN 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음

### Range

인덱스를 하나의 값이 아니라 범위로 검색

인덱스 레인지 스캔은 const, ref, range 세 가지 접근 방식을 모두 묶어서 칭하는 것이다. 

### index merge

2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후 그 결과를 병합 처리

- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다 효율성이 떨어진다.
- AND와 OR 연산이 복잡하게 연결된 쿼리에서는 제대로 최적화되지 못할 때가 많다.
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
- index_merge 접근 방식으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

### index

index접근 방식은 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔 방식이다. 

- 인덱스는 일반적으로 데이터 파일 전체보다는 크기가 작고 인덱스는 정렬되어 있으므로 풀 테이블 스캔보다는 빠르게 처리된다.
- 사용 조건
    - range나 const 또는 ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우
    - 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우
    - 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우
- limit과 같이 추가 제약조건이 들어가면 효율적이다.

### All

풀 테이블 스캔을 의미 테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거하고 반환한다. 

가장 비효율적인 방법

---

- key : 최종 선택된 실행 계획에서 사용되는 인덱스 의미
- key_len : 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려준다.
- ref : 접근 방식이 ref이면 참조 조건으로 어떤 값이 제공됐는지 보여 준다.
- rows : 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여 준다.
    - 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 디스크로부터 읽고 체크해야 하는지 의미한다.
- distinct : 특정 칼럼을 중복 없이 유일하게 가져오고 싶을 때 사용
- Using index for group-by : GROUP BY 처리가 인덱스를 이용하면 정렬된 인덱스 칼럼을 순서대로 읽으면서 그룹핑 작업만 수행한다.
    - 타이트 인덱스 스캔 : AVG(), SUM(), COUNT(*) 같이 조회하려는 값이 모든 인덱스를 다 읽어야할 때 사용
    - 루스 인덱스 스캔 : 단일 칼럼으로 구성된 인덱스에서 그룹핑 칼럼 말고는 아무것도 조회하지 않는 쿼리
    

---

## MySQL엔진에서 시간이 오래걸리는 작업

### 풀 테이블 스캔

인덱스를 사용하지 않고 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업

- 레코드의 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
- where 절이나 on 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

### ORDER BY

인덱스를 사용하지 않는 소팅 방법

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능 한 경우
- GROUP BY 의 결과 또는 DISTINCT와 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 레코드를 가져와야 하는 경우

정렬을 위한 소트 버ㅗ퍼는 세션 메모리 영역에 해당되므로 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다. 

소트 버퍼를 크게 설정해서 빠른 성능을 얻을 수는 없지만 디스크의 읽기와 쓰기 사용량은 줄일 수 있다. 

소트 버퍼를 너무 크게 설정하면 서버의 메모리가 부족해져서 MySQL 서버가 메모리 부족을 겪을 수도 있다. 

---

### 정렬 알고리즘

- 싱글 패스 : 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 되는 칼럼 전부를 담아서 정렬을 수행하는 방법.
    
    → 테이블을 두 번 읽을 필요가 없지만 정렬버퍼 공간이 많이 필요하다. 
    
- 투패스 : 정렬 대상 칼럼과 프라이머리 키값만을 소트 버퍼에 담아서 정렬을 수행하고 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 알고리즘.

정렬이 필요한 SELECT에서 * 대신 필요한 칼럼만을 가져오는 것이 효율적이다. 

## 정렬의 처리 방식

1. 옵티마이저는 정렬 처리를 하기 위해 인덱스를 이용할 수 있을지 검토한다. 
2. 인덱스를 이용 가능하면 인덱스 순서대로 읽어서 결과를 반환한다. 
3. 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리한다. 

### 인덱스를 사용한 정렬

- ORDER BY 에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고 ORDER BY 의 순서대로 생성된 인덱스가 있어야 한다.
- WHERE 절의 조건과 ORDER BY 는 같은 인덱스를 사용할 수 있어야 한다.
- B-Tree 계열의 인덱스만 사용 가능
- 정렬을 위한 추가 작업 필요 없음

### 드라이빙 테이블만 정렬

- 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행
- ORDER BY 절에 명시된 칼럼이 드라이빙 테이블의 프라이머리 키와 연관이 없으므로 인덱스를 이용한 정렬은 불가하다.
- ORDER BY 절의 정렬 기준 칼럼이 드라이빙 테이블에 포함된 칼럼이므로 드라이빙 테이블만 정렬할 수 있다.

### 임시 테이블을 이용한 정렬

2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다. 

- 정렬중에서 정렬해야할 레코드 수가 가장 많아지기 때문에 가장 느린 정렬 방법
- 드라이빙 테이블만 정렬과는 다르게 ORDER BY 절의 정렬 기준 칼럼이 드라이빙 테이블이 아니라 드리븐 테이블이다.

## 정렬 방식의 성능 비교

- 스트리밍 방식 : 서버 쪽에서 처리해야 할 데이터가 얼마나 될지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식 → 인덱스 방식
    - 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다.
    - 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장해준다.
    - LIMIT 같은 조건이 레코드를 줄이기 때문에 시간을 상당히 줄여준다.
- 버퍼링 방식 : ORDER BY 나 GROUP BY 같은 처리는 스트리밍 방식을 불가능하게 한다.
    - 서버가 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이어트는 아무 것도 하지 않고 기다려야 한다.
    - LIMIT 처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 도움이 되지 않는다.

## GROUP BY 처리

### 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)

ORDER BY 의 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그룹핑 작업을 수행하고 그 결과로 조인을 처리한다. 

- 인덱스로 처리된다 하더라도 그룹 함수 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다.

### 루스 인덱스 스캔을 이용하는 GROUP BY

루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 가져오는 것을 의미한다. 

- 임시 테이블이 필요하지 않다.
- 루스 인덱스 스캔을 사용할 수 없는 패턴
    - MIN(), MAX() 이외의 집합 함수가 사용될 때
    - GROUP BY에 사용된 카럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않을 때
    - SELECT 절의 칼럼이 GROUP BY와 일치하지 않을 때

## DISTINCT 처리

특정 칼럼의 유니크한 값만을 조회하려면 SELECT 쿼리에 DISTINCT를 사용한다. 

집합 함수가 사용되는 경우와 사용되지 않는 경우에 따라 미치는 범위가 달라진다. 

### SELECT DISTINCT

단순히 SELECT 되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용한다. 

- 정렬을 보장하지 않는다. (GROUP BY 와 다른점)
- 인덱스 이용 - 정렬 필요치 않음
- DISTINCT는 SELECT하는 레코드를 유니크하게 SELECT한느 것이지 칼럼을 유니크하게 조회하는 것이 아니다.
- SELECT 절에 사용된 DISTINCT 키워드는 조회되는 모든 칼럼에 영향을 미친다.

### 집합 함수와 함께 사용된 DISTINCT

집합 함수가 없는 SELECT 쿼리에서 DISTINCT는 조회하는 모든 칼럼의 조합이 유니크한 것만 가져온다.

→ 집합함수 내에서 사용되면 그 집합 함수의 인자로 전달된 칼럼 값이 유니크한 것들을 가져온다. 

- 인덱싱된 칼럼에 대해 DISTINCT 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행할 수 있다.

---

## 임시 테이블

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때 내부적인 테이블을 사용한다. 

### 임시 테이블이 필요한 쿼리

- ORDER BY 와 GROUP BY 에 명시된 칼럼이 다른 쿼리 → 유니크
- ORDER BY 나 GROUP BY 에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리 →유니크
- DISTINCT 와 ORDER BY 가 동시에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리 → 유니크
- UNION이나 UNION DISTINCT 가 사용된 쿼리 → 유니크
- UNION ALL이 사용된 쿼리 → 유니크 인덱스 X
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리 → 유니크 인덱스 X

→ Extra 칼럼에 “Using temporary” 라는 키워드가 있으면 사용중

유니크 인덱스가 존재하는 것이 더 느리다.

- 대용량 칼럼이 있거나 메모리의 저장공간을 넘어서면 임시테이블이 디스크에 생성된다.

---

## 조인의 종류

### JOIN(INNER JOIN)

일반적으로 조인이라 함은 INNER JOIN을 지칭한다. 

조인은 두개의 반복 루프로 두 개의 테이블을 조건에 맞게 연결해주는 작업이다. 

- 중첩된 반복 루프에서 최종적으로 선택될 레코드가 안쪽 반복 루프에 의해 결정되는 경우를 INNER JOIN 이라고 한다. → 조건을 만족하는 레코드만 조인의 결과로 가져온다.

### OUTER JOIN

조건을 만족하지 않는 레코드도 NULL로 처리하여 가져온다. 

- INNER 테이블이 조인의 결과에 영향을 미치지 않고, OUTER 테이블의 내용에 따라 조인의 결과가 결정된다.

- LEFT OUTER JOIN : 조인의 결과를 결정하는 아우터 테이블이 왼쪽
- RIGHT OUTER JOIN : 조인의 결과를 결정하는 아우터 테이블이 오른쪽

 OUTER JOIN에서 레코드가 없을 수도 있는 쪽의 테이블에 대한 조건은 반드시 LEFT JOIN ON절에 명시한다. 

### NATURAL JOIN

서로 이름이 같은 칼럼을 모두 조인 조건으로 사용. 

### Single-sweep multi join

반복 루프를 돌면서 레코드 단위로 모든 조인 대상 테이블을 차례대로 읽는 방식

### 조인 버퍼를 이용한 조인

드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면  옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인한다. 이 때 사용되는 메모리 캐시를 조인 버퍼라 한다 

- 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있다.

### INNER JOIN 과 OUTER JOIN의 선택

INNER JOIN과 OUTER JOIN은 성능을 고려해서 선택할 것이 아니라 업무 요건에 따라 선택해야한다.